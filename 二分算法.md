# 1. 使用场景
用于 logN 的查找，数据要求有序


# 2. 方法模板
- 左开右开区间，这种做法最好，无需考虑各种边界条件
- **left 和 right 含义： (-∞, left] 小于 target，[right,+∞) 大于 target**
- 中值计算方法： `int middle = left + (right - left) / 2`，防止越界
- **终止条件：left + 1 != right**
- **一般考点：找到合适的target值，偶尔target并不是直接给出的，需要自己根据题目算出来**
```
class Solution {
    public int search(int[] nums, int target) {
        // 表示(-∞, left] 小于 target
        int left = -1;
        // 表示[right,+∞) 大于 target
        int right = nums.length;
        // 二分查找
        while (left + 1 != right) {
            // 防止溢出
            int middle = left + (right - left) / 2;
            // target 位于(left, middle)中，即 right = middle
            if (nums[middle] > target) {
                right = middle;
            } 
            // target 位于(middle, right)中，即 left = middle
            else if (nums[middle] < target) {
                left = middle;
            }
            // 找到值
            else {
                return middle;
            }
        }
        // 都找不到
        return -1;
    }
}
```


# 3. 题目
## [704.二分查找](https://leetcode.cn/problems/binary-search/description/)
解法如上
## [34.在排序数组中查找元素的第一个和最后一个位置](https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/)

